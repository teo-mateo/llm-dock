BASH(1)			    General Commands Manual		       BASH(1)

NAME
       bash - GNU Bourne-Again SHell

SYNOPSIS
       bash [options] [command_string | file]

COPYRIGHT
       Bash is Copyright (C) 1989-2020 by the Free Software Foundation, Inc.

DESCRIPTION
       Bash  is	 an  sh-compatible  command language interpreter that executes
       commands read from the standard input or from a file.  Bash also incor‐
       porates useful features from the Korn and C shells (ksh and csh).

       Bash  is	 intended  to  be a conformant implementation of the Shell and
       Utilities portion  of  the  IEEE	 POSIX	specification  (IEEE  Standard
       1003.1).	 Bash can be configured to be POSIX-conformant by default.

OPTIONS
       All of the single-character shell options documented in the description
       of the set builtin command, including -o, can be used as	 options  when
       the  shell  is invoked.	In addition, bash interprets the following op‐
       tions when it is invoked:

       -c	 If the -c option is present, then commands are read from  the
		 first non-option argument command_string.  If there are argu‐
		 ments after the command_string, the  first  argument  is  as‐
		 signed	 to $0 and any remaining arguments are assigned to the
		 positional parameters.	 The assignment to $0 sets the name of
		 the shell, which is used in warning and error messages.
       -i	 If the -i option is present, the shell is interactive.
       -l	 Make bash act as if it had been invoked as a login shell (see
		 INVOCATION below).
       -r	 If the -r option is present,  the  shell  becomes  restricted
		 (see RESTRICTED SHELL below).
       -s	 If  the -s option is present, or if no arguments remain after
		 option processing, then commands are read from	 the  standard
		 input.	  This	option	allows the positional parameters to be
		 set when invoking an interactive shell or when reading	 input
		 through a pipe.
       -v	 Print shell input lines as they are read.
       -x	 Print commands and their arguments as they are executed.
       -D	 A  list of all double-quoted strings preceded by $ is printed
		 on the standard output.  These are the strings that are  sub‐
		 ject to language translation when the current locale is not C
		 or POSIX.  This implies the -n option; no  commands  will  be
		 executed.
       [-+]O [shopt_option]
		 shopt_option  is  one	of  the	 shell options accepted by the
		 shopt	builtin	 (see  SHELL  BUILTIN  COMMANDS	 below).    If
		 shopt_option is present, -O sets the value of that option; +O
		 unsets it.  If shopt_option is not supplied,  the  names  and
		 values	 of the shell options accepted by shopt are printed on
		 the standard output.  If the invocation  option  is  +O,  the
		 output is displayed in a format that may be reused as input.
       --	 A  --	signals the end of options and disables further option
		 processing.  Any arguments after the -- are treated as	 file‐
		 names and arguments.  An argument of - is equivalent to --.

       Bash  also  interprets  a number of multi-character options.  These op‐
       tions must appear on the command line before the	 single-character  op‐
       tions to be recognized.

       --debugger
	      Arrange for the debugger profile to be executed before the shell
	      starts.  Turns on extended debugging mode (see  the  description
	      of the extdebug option to the shopt builtin below).
       --dump-po-strings
	      Equivalent  to -D, but the output is in the GNU gettext po (por‐
	      table object) file format.
       --dump-strings
	      Equivalent to -D.
       --help Display a usage message on standard  output  and	exit  success‐
	      fully.
       --init-file file
       --rcfile file
	      Execute  commands	 from file instead of the system wide initial‐
	      ization file /etc/bash.bashrc and the standard personal initial‐
	      ization  file ~/.bashrc if the shell is interactive (see INVOCA‐
	      TION below).

       --login
	      Equivalent to -l.

       --noediting
	      Do not use the GNU readline library to read command  lines  when
	      the shell is interactive.

       --noprofile
	      Do  not read either the system-wide startup file /etc/profile or
	      any  of  the  personal  initialization  files   ~/.bash_profile,
	      ~/.bash_login,  or  ~/.profile.	By  default,  bash reads these
	      files when it is invoked as a login shell	 (see  INVOCATION  be‐
	      low).

       --norc Do  not  read  and  execute  the system wide initialization file
	      /etc/bash.bashrc and the personal initialization file  ~/.bashrc
	      if  the  shell  is interactive.  This option is on by default if
	      the shell is invoked as sh.

       --posix
	      Change the behavior of bash where the default operation  differs
	      from the POSIX standard to match the standard (posix mode).  See
	      SEE ALSO below for a reference to a document  that  details  how
	      posix mode affects bash's behavior.

       --restricted
	      The shell becomes restricted (see RESTRICTED SHELL below).

       --verbose
	      Equivalent to -v.

       --version
	      Show  version information for this instance of bash on the stan‐
	      dard output and exit successfully.

ARGUMENTS
       If arguments remain after option processing, and neither the -c nor the
       -s  option  has	been supplied, the first argument is assumed to be the
       name of a file containing shell commands.  If bash is invoked  in  this
       fashion,	 $0 is set to the name of the file, and the positional parame‐
       ters are set to the remaining arguments.	 Bash reads and executes  com‐
       mands  from this file, then exits.  Bash's exit status is the exit sta‐
       tus of the last command executed in the script.	If no commands are ex‐
       ecuted,	the  exit  status  is 0.  An attempt is first made to open the
       file in the current directory, and, if no file is found, then the shell
       searches the directories in PATH for the script.

INVOCATION
       A  login shell is one whose first character of argument zero is a -, or
       one started with the --login option.

       An interactive shell is one started without non-option  arguments  (un‐
       less  -s	 is  specified) and without the -c option whose standard input
       and error are both connected to terminals (as determined by isatty(3)),
       or  one	started	 with  the -i option.  PS1 is set and $- includes i if
       bash is interactive, allowing a shell script or a startup file to  test
       this state.

       The  following paragraphs describe how bash executes its startup files.
       If any of the files exist but cannot be read, bash  reports  an	error.
       Tildes  are expanded in filenames as described below under Tilde Expan‐
       sion in the EXPANSION section.

       When bash is invoked as an interactive login shell, or as a  non-inter‐
       active  shell with the --login option, it first reads and executes com‐
       mands from the file /etc/profile, if that file exists.	After  reading
       that file, it looks for ~/.bash_profile, ~/.bash_login, and ~/.profile,
       in that order, and reads and executes commands from the first one  that
       exists  and  is	readable.  The --noprofile option may be used when the
       shell is started to inhibit this behavior.

       When an interactive login shell exits, or a non-interactive login shell
       executes	 the  exit  builtin  command, bash reads and executes commands
       from the file ~/.bash_logout, if it exists.

       When an interactive shell that is not a login shell  is	started,  bash
       reads  and  executes  commands  from /etc/bash.bashrc and ~/.bashrc, if
       these files exist.  This may be inhibited by using the  --norc  option.
       The  --rcfile  file option will force bash to read and execute commands
       from file instead of /etc/bash.bashrc and ~/.bashrc.

       When bash is started non-interactively, to run a shell script, for  ex‐
       ample,  it  looks for the variable BASH_ENV in the environment, expands
       its value if it appears there, and uses the expanded value as the  name
       of  a  file to read and execute.	 Bash behaves as if the following com‐
       mand were executed:
	      if [ -n "$BASH_ENV" ]; then . "$BASH_ENV"; fi
       but the value of the PATH variable is not used to search for the	 file‐
       name.

       If  bash is invoked with the name sh, it tries to mimic the startup be‐
       havior of historical versions of sh as closely as possible, while  con‐
       forming	to the POSIX standard as well.	When invoked as an interactive
       login shell, or a non-interactive shell with  the  --login  option,  it
       first  attempts	to  read  and  execute	commands from /etc/profile and
       ~/.profile, in that order.  The --noprofile option may be used  to  in‐
       hibit  this  behavior.	When  invoked as an interactive shell with the
       name sh, bash looks for the variable ENV, expands its value  if	it  is
       defined,	 and uses the expanded value as the name of a file to read and
       execute.	 Since a shell invoked as sh does not attempt to read and exe‐
       cute  commands from any other startup files, the --rcfile option has no
       effect.	A non-interactive shell invoked with the name sh does not  at‐
       tempt to read any other startup files.  When invoked as sh, bash enters
       posix mode after the startup files are read.

       When bash is started in posix mode, as with the	--posix	 command  line
       option, it follows the POSIX standard for startup files.	 In this mode,
       interactive shells expand the ENV variable and commands	are  read  and
       executed	 from  the  file  whose	 name is the expanded value.  No other
       startup files are read.

       Bash attempts to determine when it is being run with its standard input
       connected to a network connection, as when executed by the remote shell
       daemon, usually rshd, or the secure shell daemon sshd.  If bash	deter‐
       mines  it  is being run in this fashion, it reads and executes commands
       from ~/.bashrc and ~/.bashrc, if these files exist  and	are  readable.
       It will not do this if invoked as sh.  The --norc option may be used to
       inhibit this behavior, and the --rcfile option may be used to force an‐
       other  file  to be read, but neither rshd nor sshd generally invoke the
       shell with those options or allow them to be specified.

       If the shell is started with the effective user (group) id not equal to
       the real user (group) id, and the -p option is not supplied, no startup
       files are read, shell functions are not inherited from the environment,
       the  SHELLOPTS, BASHOPTS, CDPATH, and GLOBIGNORE variables, if they ap‐
       pear in the environment, are ignored, and the effective user id is  set
       to  the	real user id.  If the -p option is supplied at invocation, the
       startup behavior is the same, but the effective user id is not reset.

DEFINITIONS
       The following definitions are used throughout the rest  of  this	 docu‐
       ment.
       blank  A space or tab.
       word   A	 sequence  of  characters  considered  as a single unit by the
	      shell.  Also known as a token.
       name   A word consisting only of	 alphanumeric  characters  and	under‐
	      scores,  and beginning with an alphabetic character or an under‐
	      score.  Also referred to as an identifier.
       metacharacter
	      A character that, when unquoted, separates words.	  One  of  the
	      following:
	      |	 & ; ( ) < > space tab newline
       control operator
	      A token that performs a control function.	 It is one of the fol‐
	      lowing symbols:
	      || & && ; ;; ;& ;;& ( ) | |& <newline>

RESERVED WORDS
       Reserved words are words that have a special meaning to the shell.  The
       following words are recognized as reserved when unquoted and either the
       first word of a command (see SHELL GRAMMAR below), the third word of  a
       case  or	 select command (only in is valid), or the third word of a for
       command (only in and do are valid):

       ! case  coproc  do done elif else esac fi for  function	if  in	select
       then until while { } time [[ ]]

SHELL GRAMMAR
   Simple Commands
       A  simple  command  is a sequence of optional variable assignments fol‐
       lowed by blank-separated words and redirections, and  terminated	 by  a
       control operator.  The first word specifies the command to be executed,
       and is passed as argument zero.	The remaining words are passed as  ar‐
       guments to the invoked command.

       The  return  value  of a simple command is its exit status, or 128+n if
       the command is terminated by signal n.

   Pipelines
       A pipeline is a sequence of one or more commands separated  by  one  of
       the control operators | or |&.  The format for a pipeline is:

	      [time [-p]] [ ! ] command [ [|⎪|&] command2 ... ]

       The  standard output of command is connected via a pipe to the standard
       input of command2.  This connection is performed	 before	 any  redirec‐
       tions specified by the command (see REDIRECTION below).	If |& is used,
       command's standard error, in addition to its standard output,  is  con‐
       nected  to  command2's standard input through the pipe; it is shorthand
       for 2>&1 |.  This implicit redirection of the  standard	error  to  the
       standard	 output	 is  performed after any redirections specified by the
       command.

       The return status of a pipeline is the exit status of the last command,
       unless  the  pipefail  option  is enabled.  If pipefail is enabled, the
       pipeline's return status is the value of the last  (rightmost)  command
       to  exit	 with a non-zero status, or zero if all commands exit success‐
       fully.  If the reserved word !  precedes a pipeline, the exit status of
       that  pipeline  is the logical negation of the exit status as described
       above.  The shell waits for all commands in the pipeline	 to  terminate
       before returning a value.

       If  the	time reserved word precedes a pipeline, the elapsed as well as
       user and system time consumed by its execution are  reported  when  the
       pipeline	 terminates.   The -p option changes the output format to that
       specified by POSIX.  When the shell is in posix mode, it does not  rec‐
       ognize  time  as	 a  reserved word if the next token begins with a `-'.
       The TIMEFORMAT variable may be set to a format  string  that  specifies
       how  the timing information should be displayed; see the description of
       TIMEFORMAT under Shell Variables below.

       When the shell is in posix mode, time may be followed by a newline.  In
       this  case,  the shell displays the total user and system time consumed
       by the shell and its children.  The TIMEFORMAT variable may be used  to
       specify the format of the time information.

       Each  command in a pipeline is executed as a separate process (i.e., in
       a subshell).  See COMMAND EXECUTION ENVIRONMENT for a description of  a
       subshell	 environment.	If  the	 lastpipe  option is enabled using the
       shopt builtin (see the description of shopt below), the last element of
       a pipeline may be run by the shell process.

   Lists
       A  list	is a sequence of one or more pipelines separated by one of the
       operators ;, &, &&, or ||, and optionally terminated by one of ;, &, or
       <newline>.

       Of these list operators, && and || have equal precedence, followed by ;
       and &, which have equal precedence.

       A sequence of one or more newlines may appear in a list	instead	 of  a
       semicolon to delimit commands.

       If  a  command  is terminated by the control operator &, the shell exe‐
       cutes the command in the background in a subshell.  The shell does  not
       wait  for the command to finish, and the return status is 0.  These are
       referred to as asynchronous commands.  Commands separated by  a	;  are
       executed sequentially; the shell waits for each command to terminate in
       turn.  The return status is the exit status of the  last	 command  exe‐
       cuted.

       AND  and	 OR  lists are sequences of one or more pipelines separated by
       the && and || control operators, respectively.  AND and	OR  lists  are
       executed with left associativity.  An AND list has the form

	      command1 && command2

       command2	 is  executed if, and only if, command1 returns an exit status
       of zero (success).

       An OR list has the form

	      command1 || command2

       command2 is executed if, and only if, command1 returns a non-zero  exit
       status.	 The  return  status of AND and OR lists is the exit status of
       the last command executed in the list.

   Compound Commands
       A compound command is one of the following.  In most cases a list in  a
       command's  description may be separated from the rest of the command by
       one or more newlines, and may be followed by a newline in  place	 of  a
       semicolon.

       (list) list  is	executed in a subshell environment (see COMMAND EXECU‐
	      TION ENVIRONMENT below).	Variable assignments and builtin  com‐
	      mands  that  affect the shell's environment do not remain in ef‐
	      fect after the command completes.	 The return status is the exit
	      status of list.

       { list; }
	      list  is simply executed in the current shell environment.  list
	      must be terminated with a newline or semicolon.  This  is	 known
	      as  a  group  command.   The return status is the exit status of
	      list.  Note that unlike the metacharacters ( and ), { and }  are
	      reserved words and must occur where a reserved word is permitted
	      to be recognized.	 Since they do not cause a  word  break,  they
	      must  be	separated  from	 list  by  whitespace or another shell
	      metacharacter.

       ((expression))
	      The expression is evaluated according to the rules described be‐
	      low under ARITHMETIC EVALUATION.	If the value of the expression
	      is non-zero, the return status is 0; otherwise the return status
	      is 1.  This is exactly equivalent to let "expression".

       [[ expression ]]
	      Return  a	 status	 of  0 or 1 depending on the evaluation of the
	      conditional expression expression.  Expressions are composed  of
	      the  primaries  described	 below	under CONDITIONAL EXPRESSIONS.
	      Word splitting and pathname expansion are not performed  on  the
	      words  between  the  [[  and  ]]; tilde expansion, parameter and
	      variable expansion, arithmetic expansion, command	 substitution,
	      process  substitution,  and quote removal are performed.	Condi‐
	      tional operators such as -f must be unquoted to be recognized as
	      primaries.

	      When  used with [[, the < and > operators sort lexicographically
	      using the current locale.

       See the description of the test builtin command (section SHELL  BUILTIN
       COMMANDS	 below)	 for the handling of parameters (i.e.  missing parame‐
       ters).

       When the == and != operators are used, the string to the right  of  the
       operator is considered a pattern and matched according to the rules de‐
       scribed below under Pattern Matching, as if the	extglob	 shell	option
       were  enabled.  The = operator is equivalent to ==.  If the nocasematch
       shell option is enabled, the match is performed without regard  to  the
       case  of	 alphabetic  characters.   The return value is 0 if the string
       matches (==) or does not match (!=) the pattern, and 1 otherwise.   Any
       part  of	 the  pattern  may be quoted to force the quoted portion to be
       matched as a string.

       An additional binary operator, =~, is available, with the  same	prece‐
       dence  as  ==  and !=.  When it is used, the string to the right of the
       operator is considered a POSIX extended regular expression and  matched
       accordingly (using the POSIX regcomp and regexec interfaces usually de‐
       scribed in regex(3)).  The return value is 0 if the string matches  the
       pattern,	 and  1 otherwise.  If the regular expression is syntactically
       incorrect, the conditional expression's return value is 2.  If the  no‐
       casematch  shell	 option is enabled, the match is performed without re‐
       gard to the case of alphabetic characters.  Any part of the pattern may
       be  quoted  to  force  the  quoted  portion  to be matched as a string.
       Bracket expressions in regular expressions must be  treated  carefully,
       since  normal  quoting characters lose their meanings between brackets.
       If the pattern is stored in a shell variable, quoting the variable  ex‐
       pansion forces the entire pattern to be matched as a string.

       The  pattern  will  match if it matches any part of the string.	Anchor
       the pattern using the ^ and $ regular expression operators to force  it
       to  match  the  entire string.  The array variable BASH_REMATCH records
       which parts of the string matched the pattern.  The element of BASH_RE‐
       MATCH  with index 0 contains the portion of the string matching the en‐
       tire regular expression.	 Substrings matched  by	 parenthesized	subex‐
       pressions  within  the  regular	expression  are saved in the remaining
       BASH_REMATCH indices. The element of BASH_REMATCH with index n  is  the
       portion of the string matching the nth parenthesized subexpression.

       Expressions  may	 be  combined using the following operators, listed in
       decreasing order of precedence:

	      ( expression )
		     Returns the value of expression.  This  may  be  used  to
		     override the normal precedence of operators.
	      ! expression
		     True if expression is false.
	      expression1 && expression2
		     True if both expression1 and expression2 are true.
	      expression1 || expression2
		     True if either expression1 or expression2 is true.

	      The && and || operators do not evaluate expression2 if the value
	      of expression1 is sufficient to determine the  return  value  of
	      the entire conditional expression.

       for name [ [ in [ word ... ] ] ; ] do list ; done
	      The list of words following in is expanded, generating a list of
	      items.  The variable name is set to each element of this list in
	      turn,  and  list is executed each time.  If the in word is omit‐
	      ted, the for command executes list once for each positional  pa‐
	      rameter  that  is set (see PARAMETERS below).  The return status
	      is the exit status of the last command that  executes.   If  the
	      expansion of the items following in results in an empty list, no
	      commands are executed, and the return status is 0.

       for (( expr1 ; expr2 ; expr3 )) ; do list ; done
	      First, the arithmetic expression expr1 is evaluated according to
	      the  rules  described  below  under  ARITHMETIC EVALUATION.  The
	      arithmetic expression expr2 is then evaluated  repeatedly	 until
	      it  evaluates  to zero.  Each time expr2 evaluates to a non-zero
	      value, list is executed and the arithmetic expression  expr3  is
	      evaluated.   If  any  expression is omitted, it behaves as if it
	      evaluates to 1.  The return value is the exit status of the last
	      command in list that is executed, or false if any of the expres‐
	      sions is invalid.

       select name [ in word ] ; do list ; done
	      The list of words following in is expanded, generating a list of
	      items.  The set of expanded words is printed on the standard er‐
	      ror, each preceded by a number.  If the in word is omitted,  the
	      positional  parameters  are printed (see PARAMETERS below).  The
	      PS3 prompt is then displayed and a line read from	 the  standard
	      input.  If the line consists of a number corresponding to one of
	      the displayed words, then the value of name is set to that word.
	      If  the line is empty, the words and prompt are displayed again.
	      If EOF is read, the command completes.   Any  other  value  read
	      causes  name  to	be set to null.	 The line read is saved in the
	      variable REPLY.  The list is executed after each selection until
	      a	 break	command is executed.  The exit status of select is the
	      exit status of the last command executed in list, or zero if  no
	      commands were executed.

       case word in [ [(] pattern [ | pattern ] ... ) list ;; ] ... esac
	      A case command first expands word, and tries to match it against
	      each pattern in turn, using the matching rules  described	 under
	      Pattern Matching below.  The word is expanded using tilde expan‐
	      sion, parameter and variable  expansion,	arithmetic  expansion,
	      command  substitution,  process  substitution and quote removal.
	      Each pattern examined is expanded using tilde expansion, parame‐
	      ter  and	variable expansion, arithmetic expansion, command sub‐
	      stitution, and process substitution.  If the  nocasematch	 shell
	      option  is enabled, the match is performed without regard to the
	      case of alphabetic characters.  When a match is found, the  cor‐
	      responding  list	is  executed.	If the ;; operator is used, no
	      subsequent matches are attempted after the first pattern	match.
	      Using  ;&	 in  place of ;; causes execution to continue with the
	      list associated with the next set of  patterns.	Using  ;;&  in
	      place  of	 ;;  causes the shell to test the next pattern list in
	      the statement, if any, and execute any associated list on a suc‐
	      cessful match, continuing the case statement execution as if the
	      pattern list had not matched.  The exit status  is  zero	if  no
	      pattern  matches.	  Otherwise, it is the exit status of the last
	      command executed in list.

       if list; then list; [ elif list; then list; ] ... [ else list; ] fi
	      The if list is executed.	If its exit status is zero,  the  then
	      list  is	executed.   Otherwise,	each  elif list is executed in
	      turn, and if its exit status is  zero,  the  corresponding  then
	      list is executed and the command completes.  Otherwise, the else
	      list is executed, if present.  The exit status is the exit  sta‐
	      tus of the last command executed, or zero if no condition tested
	      true.

       while list-1; do list-2; done
       until list-1; do list-2; done
	      The while command continuously executes the list list-2 as  long
	      as the last command in the list list-1 returns an exit status of
	      zero.  The until command is identical to the while command,  ex‐
	      cept that the test is negated: list-2 is executed as long as the
	      last command in list-1 returns a non-zero exit status.  The exit
	      status of the while and until commands is the exit status of the
	      last command executed in list-2, or zero if none was executed.

   Coprocesses
       A coprocess is a shell command preceded by the coproc reserved word.  A
       coprocess  is  executed asynchronously in a subshell, as if the command
       had been terminated with the & control operator, with  a	 two-way  pipe
       established between the executing shell and the coprocess.

       The format for a coprocess is:

	      coproc [NAME] command [redirections]

       This  creates a coprocess named NAME.  If NAME is not supplied, the de‐
       fault name is COPROC.  NAME must not be supplied if command is a simple
       command	(see above); otherwise, it is interpreted as the first word of
       the simple command.  When the coprocess is executed, the shell  creates
       an  array  variable (see Arrays below) named NAME in the context of the
       executing shell.	 The standard output of command	 is  connected	via  a
       pipe  to	 a  file  descriptor in the executing shell, and that file de‐
       scriptor is assigned to NAME[0].	 The standard input of command is con‐
       nected via a pipe to a file descriptor in the executing shell, and that
       file descriptor is assigned to NAME[1].	This pipe is  established  be‐
       fore any redirections specified by the command (see REDIRECTION below).
       The file descriptors can be utilized as arguments to shell commands and
       redirections  using standard word expansions.  Other than those created
       to execute command and process substitutions, the file descriptors  are
       not available in subshells.  The process ID of the shell spawned to ex‐
       ecute the coprocess is available as the value of the variable NAME_PID.
       The  wait builtin command may be used to wait for the coprocess to ter‐
       minate.

       Since the coprocess is created as an asynchronous command,  the	coproc
       command	always	returns	 success.  The return status of a coprocess is
       the exit status of command.

   Shell Function Definitions
       A shell function is an object that is called like a simple command  and
       executes	 a  compound  command with a new set of positional parameters.
       Shell functions are declared as follows:

       fname () compound-command [redirection]
       function fname [()] compound-command [redirection]
	      This defines a function named fname.  The reserved word function
	      is  optional.   If  the  function reserved word is supplied, the
	      parentheses are optional.	 The body of the function is the  com‐
	      pound  command  compound-command	(see Compound Commands above).
	      That command is usually a list of commands between { and },  but
	      may  be  any  command listed under Compound Commands above, with
	      one exception: If the function reserved word is  used,  but  the
	      parentheses  are	not  supplied,	the braces are required.  com‐
	      pound-command is executed whenever fname	is  specified  as  the
	      name  of	a simple command.  When in posix mode, fname must be a
	      valid shell name and may not be the name of  one	of  the	 POSIX
	      special  builtins.   In default mode, a function name can be any
	      unquoted shell word that does not contain $.   Any  redirections
	      (see REDIRECTION below) specified when a function is defined are
	      performed when the function is executed.	The exit status	 of  a
	      function	definition  is	zero unless a syntax error occurs or a
	      readonly function with the same name already exists.  When  exe‐
	      cuted,  the  exit status of a function is the exit status of the
	      last command executed in the body.  (See FUNCTIONS below.)

COMMENTS
       In a non-interactive shell, or an interactive shell in which the inter‐
       active_comments	option	to  the	 shopt	builtin	 is enabled (see SHELL
       BUILTIN COMMANDS below), a word beginning with # causes that  word  and
       all  remaining  characters  on that line to be ignored.	An interactive
       shell without the interactive_comments option enabled  does  not	 allow
       comments.  The interactive_comments option is on by default in interac‐
       tive shells.

QUOTING
       Quoting is used to remove the special meaning of certain characters  or
       words  to  the shell.  Quoting can be used to disable special treatment
       for special characters, to prevent reserved words from being recognized
       as such, and to prevent parameter expansion.

       Each  of	 the metacharacters listed above under DEFINITIONS has special
       meaning to the shell and must be quoted if it is to represent itself.

       When the command history expansion facilities are being used (see  HIS‐
       TORY EXPANSION below), the history expansion character, usually !, must
       be quoted to prevent history expansion.

       There are  three	 quoting  mechanisms:  the  escape  character,	single
       quotes, and double quotes.

       A  non-quoted  backslash (\) is the escape character.  It preserves the
       literal value of the next character that follows, with the exception of
       <newline>.   If a \<newline> pair appears, and the backslash is not it‐
       self quoted, the \<newline> is treated as a line continuation (that is,
       it is removed from the input stream and effectively ignored).

       Enclosing  characters  in  single quotes preserves the literal value of
       each character within the quotes.  A single quote may not occur between
       single quotes, even when preceded by a backslash.

       Enclosing  characters  in  double quotes preserves the literal value of
       all characters within the quotes, with the exception of $, `,  \,  and,
       when history expansion is enabled, !.  When the shell is in posix mode,
       the ! has no special meaning within double quotes,  even	 when  history
       expansion  is  enabled.	 The  characters  $ and ` retain their special
       meaning within double quotes.  The backslash retains its special	 mean‐
       ing  only when followed by one of the following characters: $, `, ", \,
       or <newline>.  A double quote may be quoted  within  double  quotes  by
       preceding  it  with a backslash.	 If enabled, history expansion will be
       performed unless an !  appearing in double quotes is  escaped  using  a
       backslash.  The backslash preceding the !  is not removed.

       The  special  parameters	 *  and	 @ have special meaning when in double
       quotes (see PARAMETERS below).

       Words of the form $'string' are treated specially.  The word expands to
       string,	with backslash-escaped characters replaced as specified by the
       ANSI C standard.	 Backslash escape sequences, if present,  are  decoded
       as follows:
	      \a     alert (bell)
	      \b     backspace
	      \e
	      \E     an escape character
	      \f     form feed
	      \n     new line
	      \r     carriage return
	      \t     horizontal tab
	      \v     vertical tab
	      \\     backslash
	      \'     single quote
	      \"     double quote
	      \?     question mark
	      \nnn   the  eight-bit  character	whose value is the octal value
		     nnn (one to three octal digits)
	      \xHH   the eight-bit character whose value  is  the  hexadecimal
		     value HH (one or two hex digits)
	      \uHHHH the  Unicode (ISO/IEC 10646) character whose value is the
		     hexadecimal value HHHH (one to four hex digits)
	      \UHHHHHHHH
		     the Unicode (ISO/IEC 10646) character whose value is  the
		     hexadecimal value HHHHHHHH (one to eight hex digits)
	      \cx    a control-x character

       The  expanded  result  is  single-quoted, as if the dollar sign had not
       been present.

       A double-quoted string preceded by a dollar sign ($"string") will cause
       the  string to be translated according to the current locale.  The get‐
       text infrastructure performs the message catalog	 lookup	 and  transla‐
       tion,  using  the  LC_MESSAGES  and TEXTDOMAIN shell variables.	If the
       current locale is C or POSIX, or if there are  no  translations	avail‐
       able,  the dollar sign is ignored.  If the string is translated and re‐
       placed, the replacement is double-quoted.

PARAMETERS
       A parameter is an entity that stores values.  It can be a name, a  num‐
       ber, or one of the special characters listed below under Special Param‐
       eters.  A variable is a parameter denoted by a name.  A variable has  a
       value  and  zero or more attributes.  Attributes are assigned using the
       declare builtin command (see declare below in SHELL BUILTIN COMMANDS).

       A parameter is set if it has been assigned a value.  The null string is
       a  valid	 value.	 Once a variable is set, it may be unset only by using
       the unset builtin command (see SHELL BUILTIN COMMANDS below).

       A variable may be assigned to by a statement of the form

	      name=[value]

       If value is not given, the variable is assigned the null	 string.   All
       values  undergo tilde expansion, parameter and variable expansion, com‐
       mand substitution, arithmetic expansion, and quote removal (see	EXPAN‐
       SION below).  If the variable has its integer attribute set, then value
       is evaluated as an arithmetic expression even if the $((...)) expansion
       is  not	used  (see Arithmetic Expansion below).	 Word splitting is not
       performed, with the exception of "$@" as explained below under  Special
       Parameters.   Pathname  expansion  is not performed.  Assignment state‐
       ments may also appear as arguments to the alias, declare, typeset,  ex‐
       port,  readonly,	 and  local  builtin  commands (declaration commands).
       When in posix mode, these builtins may appear in a command after one or
       more  instances	of  the	 command  builtin  and retain these assignment
       statement properties.

       In the context where an assignment statement is assigning a value to  a
       shell variable or array index, the += operator can be used to append to
       or add to the variable's previous value.	 This  includes	 arguments  to
       builtin	commands  such	as  declare  that accept assignment statements
       (declaration commands).	When += is applied to a variable for which the
       integer attribute has been set, value is evaluated as an arithmetic ex‐
       pression and added to the variable's current value, which is also eval‐
       uated.	When += is applied to an array variable using compound assign‐
       ment (see Arrays below), the variable's value is not unset  (as	it  is
       when  using  =),	 and new values are appended to the array beginning at
       one greater than the array's maximum  index  (for  indexed  arrays)  or
       added  as additional key-value pairs in an associative array.  When ap‐
       plied to a string-valued variable, value is expanded  and  appended  to
       the variable's value.

       A variable can be assigned the nameref attribute using the -n option to
       the declare or local builtin commands (see the descriptions of  declare
       and  local  below) to create a nameref, or a reference to another vari‐
       able.  This allows variables to be  manipulated	indirectly.   Whenever
       the  nameref variable is referenced, assigned to, unset, or has its at‐
       tributes modified (other than using or changing the  nameref  attribute
       itself),	 the operation is actually performed on the variable specified
       by the nameref variable's value.	 A nameref  is	commonly  used	within
       shell functions to refer to a variable whose name is passed as an argu‐
       ment to the function.  For instance, if a variable name is passed to  a
       shell function as its first argument, running
	      declare -n ref=$1
       inside  the  function creates a nameref variable ref whose value is the
       variable name passed as the first argument.  References and assignments
       to  ref,	 and changes to its attributes, are treated as references, as‐
       signments, and attribute modifications to the variable whose  name  was
       passed  as  $1.	 If the control variable in a for loop has the nameref
       attribute, the list of words can be a list of shell  variables,	and  a
       name  reference will be established for each word in the list, in turn,
       when the loop is executed.  Array variables cannot be given the nameref
       attribute.   However,  nameref  variables can reference array variables
       and subscripted array variables.	 Namerefs can be unset	using  the  -n
       option  to the unset builtin.  Otherwise, if unset is executed with the
       name of a nameref variable as an argument, the variable	referenced  by
       the nameref variable will be unset.

   Positional Parameters
       A  positional  parameter	 is a parameter denoted by one or more digits,
       other than the single digit 0.  Positional parameters are assigned from
       the  shell's  arguments when it is invoked, and may be reassigned using
       the set builtin command.	 Positional parameters may not be assigned  to
       with  assignment statements.  The positional parameters are temporarily
       replaced when a shell function is executed (see FUNCTIONS below).

       When a positional parameter consisting of more than a single  digit  is
       expanded, it must be enclosed in braces (see EXPANSION below).

   Special Parameters
       The  shell  treats  several parameters specially.  These parameters may
       only be referenced; assignment to them is not allowed.
       *      Expands to the positional parameters, starting from  one.	  When
	      the  expansion  is not within double quotes, each positional pa‐
	      rameter expands to a separate word.  In  contexts	 where	it  is
	      performed, those words are subject to further word splitting and
	      pathname expansion.  When the  expansion	occurs	within	double
	      quotes,  it  expands to a single word with the value of each pa‐
	      rameter separated by the first  character	 of  the  IFS  special
	      variable.	  That	is, "$*" is equivalent to "$1c$2c...", where c
	      is the first character of the value of the IFS variable.	If IFS
	      is  unset,  the  parameters  are separated by spaces.  If IFS is
	      null, the parameters are joined without intervening separators.
       @      Expands to the positional parameters,  starting  from  one.   In
	      contexts	where  word  splitting is performed, this expands each
	      positional parameter to a separate word; if  not	within	double
	      quotes,  these words are subject to word splitting.  In contexts
	      where word splitting is not performed, this expands to a	single
	      word  with each positional parameter separated by a space.  When
	      the expansion occurs within double quotes,  each	parameter  ex‐
	      pands  to	 a separate word.  That is, "$@" is equivalent to "$1"
	      "$2" ...	If the double-quoted expansion occurs within  a	 word,
	      the  expansion  of the first parameter is joined with the begin‐
	      ning part of the original word, and the expansion	 of  the  last
	      parameter	 is  joined  with  the last part of the original word.
	      When there are no positional parameters, "$@" and $@  expand  to
	      nothing (i.e., they are removed).
       #      Expands to the number of positional parameters in decimal.
       ?      Expands  to  the exit status of the most recently executed fore‐
	      ground pipeline.
       -      Expands to the current option flags as  specified	 upon  invoca‐
	      tion,  by the set builtin command, or those set by the shell it‐
	      self (such as the -i option).
       $      Expands to the process ID of the shell.  In a  ()	 subshell,  it
	      expands  to  the	process	 ID of the current shell, not the sub‐
	      shell.
       !      Expands to the process ID of the job most recently  placed  into
	      the  background,	whether executed as an asynchronous command or
	      using the bg builtin (see JOB CONTROL below).
       0      Expands to the name of the shell or shell script.	 This  is  set
	      at shell initialization.	If bash is invoked with a file of com‐
	      mands, $0 is set to the name of that file.  If bash  is  started
	      with  the	 -c option, then $0 is set to the first argument after
	      the string to be executed, if one is present.  Otherwise, it  is
	      set  to  the  filename used to invoke bash, as given by argument
	      zero.

   Shell Variables
       The following variables are set by the shell:

       _      At shell startup, set to the pathname used to invoke  the	 shell
	      or  shell	 script being executed as passed in the environment or
	      argument list.  Subsequently, expands to the  last  argument  to
	      the  previous  simple  command executed in the foreground, after
	      expansion.  Also set to the full pathname used  to  invoke  each
	      command  executed and placed in the environment exported to that
	      command.	When checking mail, this parameter holds the  name  of
	      the mail file currently being checked.
       BASH   Expands  to  the	full  filename used to invoke this instance of
	      bash.
       BASHOPTS
	      A colon-separated list of enabled shell options.	Each  word  in
	      the  list	 is  a	valid  argument for the -s option to the shopt
	      builtin command (see SHELL BUILTIN COMMANDS below).  The options
	      appearing	 in  BASHOPTS  are  those reported as on by shopt.  If
	      this variable is in the environment when bash  starts  up,  each
	      shell  option  in	 the  list  will be enabled before reading any
	      startup files.  This variable is read-only.
       BASHPID
	      Expands to the process ID of the	current	 bash  process.	  This
	      differs  from  $$ under certain circumstances, such as subshells
	      that do not require bash to be re-initialized.   Assignments  to
	      BASHPID  have no effect.	If BASHPID is unset, it loses its spe‐
	      cial properties, even if it is subsequently reset.
       BASH_ALIASES
	      An associative array variable whose members  correspond  to  the
	      internal	list  of  aliases  as maintained by the alias builtin.
	      Elements added to this array appear in the alias list;  however,
	      unsetting	 array elements currently does not cause aliases to be
	      removed from the alias list.  If BASH_ALIASES is unset, it loses
	      its special properties, even if it is subsequently reset.
       BASH_ARGC
	      An  array	 variable whose values are the number of parameters in
	      each frame of the current bash execution call stack.  The number
	      of  parameters  to  the  current	subroutine  (shell function or
	      script executed with . or source) is at the top  of  the	stack.
	      When  a  subroutine is executed, the number of parameters passed
	      is pushed onto BASH_ARGC.	 The shell sets BASH_ARGC only when in
	      extended debugging mode (see the description of the extdebug op‐
	      tion to the shopt builtin below).	 Setting  extdebug  after  the
	      shell has started to execute a script, or referencing this vari‐
	      able when extdebug is not set, may result in  inconsistent  val‐
	      ues.
       BASH_ARGV
	      An  array	 variable containing all of the parameters in the cur‐
	      rent bash execution call stack.  The final parameter of the last
	      subroutine  call is at the top of the stack; the first parameter
	      of the initial call is at the bottom.  When a subroutine is exe‐
	      cuted,  the  parameters supplied are pushed onto BASH_ARGV.  The
	      shell sets BASH_ARGV only when in extended debugging  mode  (see
	      the  description of the extdebug option to the shopt builtin be‐
	      low).  Setting extdebug after the shell has started to execute a
	      script,  or  referencing this variable when extdebug is not set,
	      may result in inconsistent values.
       BASH_ARGV0
	      When referenced, this variable expands to the name of the	 shell
	      or shell script (identical to $0; see the description of special
	      parameter 0 above).  Assignment to BASH_ARGV0 causes  the	 value
	      assigned	to also be assigned to $0.  If BASH_ARGV0 is unset, it
	      loses its special properties, even if it is subsequently reset.
       BASH_CMDS
	      An associative array variable whose members  correspond  to  the
	      internal	hash  table  of	 commands  as  maintained  by the hash
	      builtin.	Elements added to this array appear in the hash table;
	      however,	unsetting array elements currently does not cause com‐
	      mand names to be removed from the hash table.  If	 BASH_CMDS  is
	      unset,  it  loses	 its  special properties, even if it is subse‐
	      quently reset.
       BASH_COMMAND
	      The command currently being executed or about  to	 be  executed,
	      unless the shell is executing a command as the result of a trap,
	      in which case it is the command executing at  the	 time  of  the
	      trap.   If  BASH_COMMAND	is unset, it loses its special proper‐
	      ties, even if it is subsequently reset.
       BASH_EXECUTION_STRING
	      The command argument to the -c invocation option.
       BASH_LINENO
	      An array variable whose members are the line numbers  in	source
	      files  where  each corresponding member of FUNCNAME was invoked.
	      ${BASH_LINENO[$i]}  is  the  line	 number	 in  the  source  file
	      (${BASH_SOURCE[$i+1]})  where  ${FUNCNAME[$i]}  was  called  (or
	      ${BASH_LINENO[$i-1]} if referenced within	 another  shell	 func‐
	      tion).  Use LINENO to obtain the current line number.
       BASH_LOADABLES_PATH
	      A	 colon-separated  list of directories in which the shell looks
	      for dynamically loadable builtins specified by the  enable  com‐
	      mand.
       BASH_REMATCH
	      An  array	 variable  whose members are assigned by the =~ binary
	      operator to the [[ conditional command.  The element with	 index
	      0	 is  the portion of the string matching the entire regular ex‐
	      pression.	 The element with index n is the portion of the string
	      matching the nth parenthesized subexpression.
       BASH_SOURCE
	      An  array	 variable whose members are the source filenames where
	      the corresponding shell function names  in  the  FUNCNAME	 array
	      variable are defined.  The shell function ${FUNCNAME[$i]} is de‐
	      fined  in	 the   file   ${BASH_SOURCE[$i]}   and	 called	  from
	      ${BASH_SOURCE[$i+1]}.
       BASH_SUBSHELL
	      Incremented  by one within each subshell or subshell environment
	      when the shell begins executing in that environment.   The  ini‐
	      tial  value  is 0.  If BASH_SUBSHELL is unset, it loses its spe‐
	      cial properties, even if it is subsequently reset.
       BASH_VERSINFO
	      A readonly array variable whose members hold version information
	      for  this	 instance  of  bash.  The values assigned to the array
	      members are as follows:
	      BASH_VERSINFO[0]	      The major version number (the release).
	      BASH_VERSINFO[1]	      The minor version number (the version).
	      BASH_VERSINFO[2]	      The patch level.
	      BASH_VERSINFO[3]	      The build version.
	      BASH_VERSINFO[4]	      The release status (e.g., beta1).
	      BASH_VERSINFO[5]	      The value of MACHTYPE.
       BASH_VERSION
	      Expands to a string describing the version of this  instance  of
	      bash.
       COMP_CWORD
	      An  index	 into ${COMP_WORDS} of the word containing the current
	      cursor position.	This variable is available only in shell func‐
	      tions  invoked  by  the  programmable completion facilities (see
	      Programmable Completion below).
       COMP_KEY
	      The key (or final key of a key sequence) used to invoke the cur‐
	      rent completion function.
       COMP_LINE
	      The  current  command  line.  This variable is available only in
	      shell functions and external commands invoked  by	 the  program‐
	      mable completion facilities (see Programmable Completion below).
       COMP_POINT
	      The  index of the current cursor position relative to the begin‐
	      ning of the current command.  If the current cursor position  is
	      at the end of the current command, the value of this variable is
	      equal to ${#COMP_LINE}.  This  variable  is  available  only  in
	      shell  functions	and  external commands invoked by the program‐
	      mable completion facilities (see Programmable Completion below).
       COMP_TYPE
	      Set to an integer value corresponding to the type of  completion
	      attempted	 that  caused a completion function to be called: TAB,
	      for normal completion, ?, for listing completions after  succes‐
	      sive  tabs,  !, for listing alternatives on partial word comple‐
	      tion, @, to list completions if the word is not  unmodified,  or
	      %,  for  menu  completion.   This	 variable is available only in
	      shell functions and external commands invoked  by	 the  program‐
	      mable completion facilities (see Programmable Completion below).
       COMP_WORDBREAKS
	      The  set	of characters that the readline library treats as word
	      separators when performing word completion.  If  COMP_WORDBREAKS
	      is  unset, it loses its special properties, even if it is subse‐
	      quently reset.
       COMP_WORDS
	      An array variable (see Arrays below) consisting of the  individ‐
	      ual  words  in the current command line.	The line is split into
	      words as readline would split it, using COMP_WORDBREAKS  as  de‐
	      scribed  above.	This variable is available only in shell func‐
	      tions invoked by the  programmable  completion  facilities  (see
	      Programmable Completion below).
       COPROC An  array	 variable  (see Arrays below) created to hold the file
	      descriptors for output from and input to	an  unnamed  coprocess
	      (see Coprocesses above).
       DIRSTACK
	      An array variable (see Arrays below) containing the current con‐
	      tents of the directory stack.  Directories appear in  the	 stack
	      in  the order they are displayed by the dirs builtin.  Assigning
	      to members of this array variable may be used to modify directo‐
	      ries  already in the stack, but the pushd and popd builtins must
	      be used to add and remove directories.  Assignment to this vari‐
	      able  will not change the current directory.  If DIRSTACK is un‐
	      set, it loses its special properties, even if it is subsequently
	      reset.
       EPOCHREALTIME
	      Each time this parameter is referenced, it expands to the number
	      of seconds since the Unix Epoch  (see  time(3))  as  a  floating
	      point  value  with  micro-second	granularity.   Assignments  to
	      EPOCHREALTIME are ignored.  If EPOCHREALTIME is unset, it	 loses
	      its special properties, even if it is subsequently reset.
       EPOCHSECONDS
	      Each time this parameter is referenced, it expands to the number
	      of seconds since the Unix Epoch (see time(3)).   Assignments  to
	      EPOCHSECONDS  are	 ignored.   If EPOCHSECONDS is unset, it loses
	      its special properties, even if it is subsequently reset.
       EUID   Expands to the effective user ID of the current  user,  initial‐
	      ized at shell startup.  This variable is readonly.
       FUNCNAME
	      An  array	 variable  containing the names of all shell functions
	      currently in the execution call stack.  The element with index 0
	      is the name of any currently-executing shell function.  The bot‐
	      tom-most element (the one with the  highest  index)  is  "main".
	      This  variable  exists  only when a shell function is executing.
	      Assignments to FUNCNAME have no effect.  If FUNCNAME  is	unset,
	      it  loses its special properties, even if it is subsequently re‐
	      set.

	      This variable can be  used  with	BASH_LINENO  and  BASH_SOURCE.
	      Each   element   of   FUNCNAME  has  corresponding  elements  in
	      BASH_LINENO and BASH_SOURCE to describe the call stack.  For in‐
	      stance,	 ${FUNCNAME[$i]}    was	   called    from   the	  file
	      ${BASH_SOURCE[$i+1]} at  line  number  ${BASH_LINENO[$i]}.   The
	      caller builtin displays the current call stack using this infor‐
	      mation.
       GROUPS An array variable containing the list of	groups	of  which  the
	      current user is a member.	 Assignments to GROUPS have no effect.
	      If GROUPS is unset, it loses its special properties, even if  it
	      is subsequently reset.
       HISTCMD
	      The history number, or index in the history list, of the current
	      command.	Assignments to HISTCMD are ignored.  If HISTCMD is un‐
	      set, it loses its special properties, even if it is subsequently
	      reset.
       HOSTNAME
	      Automatically set to the name of the current host.
       HOSTTYPE
	      Automatically set to a string that uniquely describes  the  type
	      of  machine  on which bash is executing.	The default is system-
	      dependent.
       LINENO Each time this parameter is referenced, the shell substitutes  a
	      decimal  number  representing the current sequential line number
	      (starting with 1) within a script or function.  When  not	 in  a
	      script  or  function, the value substituted is not guaranteed to
	      be meaningful.  If LINENO is unset, it loses its special proper‐
	      ties, even if it is subsequently reset.
       MACHTYPE
	      Automatically  set  to  a string that fully describes the system
	      type on which bash is executing, in the  standard	 GNU  cpu-com‐
	      pany-system format.  The default is system-dependent.
       MAPFILE
	      An  array	 variable  (see Arrays below) created to hold the text
	      read by the mapfile builtin when no variable name is supplied.
       OLDPWD The previous working directory as set by the cd command.
       OPTARG The value of the last option argument processed by  the  getopts
	      builtin command (see SHELL BUILTIN COMMANDS below).
       OPTIND The  index  of  the next argument to be processed by the getopts
	      builtin command (see SHELL BUILTIN COMMANDS below).
       OSTYPE Automatically set to a string that describes the operating  sys‐
	      tem  on  which  bash is executing.  The default is system-depen‐
	      dent.
       PIPESTATUS
	      An array variable (see Arrays below) containing a list  of  exit
	      status  values  from the processes in the most-recently-executed
	      foreground pipeline (which may contain only a single command).
       PPID   The process ID of the shell's parent.  This  variable  is	 read‐
	      only.
       PWD    The current working directory as set by the cd command.
       RANDOM Each  time  this parameter is referenced, it expands to a random
	      integer between 0 and 32767.  Assigning a value to  RANDOM  ini‐
	      tializes	(seeds)	 the sequence of random numbers.  If RANDOM is
	      unset, it loses its special properties, even  if	it  is	subse‐
	      quently reset.
       READLINE_LINE
	      The contents of the readline line buffer, for use with "bind -x"
	      (see SHELL BUILTIN COMMANDS below).
       READLINE_MARK
	      The position of the mark (saved insertion point) in the readline
	      line  buffer, for use with "bind -x" (see SHELL BUILTIN COMMANDS
	      below).  The characters between the insertion point and the mark
	      are often called the region.
       READLINE_POINT
	      The position of the insertion point in the readline line buffer,
	      for use with "bind -x" (see SHELL BUILTIN COMMANDS below).
       REPLY  Set to the line of input read by the read builtin	 command  when
	      no arguments are supplied.
       SECONDS
	      Each  time  this	parameter is referenced, the number of seconds
	      since shell invocation is returned.  If a value is  assigned  to
	      SECONDS,	the  value  returned upon subsequent references is the
	      number of seconds since the assignment plus the value  assigned.
	      The  number  of seconds at shell invocation and the current time
	      is always determined by querying the system clock.   If  SECONDS
	      is  unset, it loses its special properties, even if it is subse‐
	      quently reset.
       SHELLOPTS
	      A colon-separated list of enabled shell options.	Each  word  in
	      the  list	 is  a	valid  argument	 for  the -o option to the set
	      builtin command (see SHELL BUILTIN COMMANDS below).  The options
	      appearing	 in  SHELLOPTS are those reported as on by set -o.  If
	      this variable is in the environment when bash  starts  up,  each
	      shell  option  in	 the  list  will be enabled before reading any
	      startup files.  This variable is read-only.
       SHLVL  Incremented by one each time an instance of bash is started.
       SRANDOM
	      This variable expands to a 32-bit pseudo-random number each time
	      it  is  referenced. The random number generator is not linear on
	      systems that support /dev/urandom or  arc4random,	 so  each  re‐
	      turned  number  has no relationship to the numbers preceding it.
	      The random number generator cannot be seeded, so assignments  to
	      this variable have no effect.  If SRANDOM is unset, it loses its
	      special properties, even if it is subsequently reset.
       UID    Expands to the user ID of the current user, initialized at shell
	      startup.	This variable is readonly.

       The following variables are used by the shell.  In some cases, bash as‐
       signs a default value to a variable; these cases are noted below.

       BASH_COMPAT
	      The value is used to set the shell's compatibility  level.   See
	      SHELL  COMPATIBILITY MODE below for a description of the various
	      compatibility levels and their effects.  The value may be a dec‐
	      imal  number  (e.g., 4.2) or an integer (e.g., 42) corresponding
	      to the desired compatibility level.  If BASH_COMPAT is unset  or
	      set  to  the empty string, the compatibility level is set to the
	      default for the current version.	If BASH_COMPAT	is  set	 to  a
	      value  that  is  not  one of the valid compatibility levels, the
	      shell prints an error message and sets the  compatibility	 level
	      to the default for the current version.  The valid values corre‐
	      spond to the compatibility levels described below under  BSHELL‐
	      COMPATIBILITYMODE.   For	example,  4.2  and 42 are valid values
	      that correspond to the compat42 shopt option and set the compat‐
	      ibility level to 42.  The current version is also a valid value.
       BASH_ENV
	      If  this parameter is set when bash is executing a shell script,
	      its value is interpreted as a filename  containing  commands  to
	      initialize the shell, as in ~/.bashrc.  The value of BASH_ENV is
	      subjected to  parameter  expansion,  command  substitution,  and
	      arithmetic  expansion  before  being  interpreted as a filename.
	      PATH is not used to search for the resultant filename.
       BASH_XTRACEFD
	      If set to an integer corresponding to a valid  file  descriptor,
	      bash  will  write	 the trace output generated when set -x is en‐
	      abled to that file descriptor.  The file	descriptor  is	closed
	      when  BASH_XTRACEFD is unset or assigned a new value.  Unsetting
	      BASH_XTRACEFD or assigning it the empty string causes the	 trace
	      output  to  be  sent  to	the standard error.  Note that setting
	      BASH_XTRACEFD to 2 (the standard error file descriptor) and then
	      unsetting it will result in the standard error being closed.
       CDPATH The  search  path for the cd command.  This is a colon-separated
	      list of directories in which the shell looks for destination di‐
	      rectories	 specified  by	the  cd	 command.   A  sample value is
	      ".:~:/usr".
       CHILD_MAX
	      Set the number of exited child status values for	the  shell  to
	      remember.	  Bash will not allow this value to be decreased below
	      a POSIX-mandated minimum, and there is  a	 maximum  value	 (cur‐
	      rently  8192)  that  this	 may not exceed.  The minimum value is
	      system-dependent.
       COLUMNS
	      Used by the select compound command to  determine	 the  terminal
	      width  when  printing selection lists.  Automatically set if the
	      checkwinsize option is enabled or in an interactive  shell  upon
	      receipt of a SIGWINCH.
       COMPREPLY
	      An array variable from which bash reads the possible completions
	      generated by a shell function invoked by the  programmable  com‐
	      pletion  facility (see Programmable Completion below).  Each ar‐
	      ray element contains one possible completion.
       EMACS  If bash finds this variable in the environment  when  the	 shell
	      starts  with  value "t", it assumes that the shell is running in
	      an Emacs shell buffer and disables line editing.
       ENV    Expanded and executed  similarly	to  BASH_ENV  (see  INVOCATION
	      above) when an interactive shell is invoked in posix mode.
       EXECIGNORE
	      A	 colon-separated list of shell patterns (see Pattern Matching)
	      defining the list of filenames to be ignored by  command	search
	      using  PATH.  Files whose full pathnames match one of these pat‐
	      terns are not considered executable files for  the  purposes  of
	      completion and command execution via PATH lookup.	 This does not
	      affect the behavior of the [, test, and [[ commands.  Full path‐
	      names  in	 the command hash table are not subject to EXECIGNORE.
	      Use this variable to ignore shared library files that  have  the
	      executable  bit  set, but are not executable files.  The pattern
	      matching honors the setting of the extglob shell option.
       FCEDIT The default editor for the fc builtin command.
       FIGNORE
	      A colon-separated list of suffixes  to  ignore  when  performing
	      filename completion (see READLINE below).	 A filename whose suf‐
	      fix matches one of the entries in FIGNORE is excluded  from  the
	      list of matched filenames.  A sample value is ".o:~" (Quoting is
	      needed when assigning a value to this variable,  which  contains
	      tildes).
       FUNCNEST
	      If  set  to  a  numeric  value greater than 0, defines a maximum
	      function nesting level.  Function invocations that  exceed  this
	      nesting level will cause the current command to abort.
       GLOBIGNORE
	      A	 colon-separated  list	of  patterns  defining the set of file
	      names to be ignored by  pathname	expansion.   If	 a  file  name
	      matched  by a pathname expansion pattern also matches one of the
	      patterns in GLOBIGNORE, it is removed from the list of matches.
       HISTCONTROL
	      A colon-separated list of values controlling  how	 commands  are
	      saved  on	 the history list.  If the list of values includes ig‐
	      norespace, lines which begin with	 a  space  character  are  not
	      saved  in	 the history list.  A value of ignoredups causes lines
	      matching the previous history entry to not be saved.  A value of
	      ignoreboth is shorthand for ignorespace and ignoredups.  A value
	      of erasedups causes all previous lines matching the current line
	      to  be  removed from the history list before that line is saved.
	      Any value not in the above list is ignored.  If  HISTCONTROL  is
	      unset,  or does not include a valid value, all lines read by the
	      shell parser are saved on the history list, subject to the value
	      of  HISTIGNORE.  The second and subsequent lines of a multi-line
	      compound command are not tested, and are added  to  the  history
	      regardless of the value of HISTCONTROL.
       HISTFILE
	      The name of the file in which command history is saved (see HIS‐
	      TORY below).  The default value is ~/.bash_history.   If	unset,
	      the command history is not saved when a shell exits.
       HISTFILESIZE
	      The maximum number of lines contained in the history file.  When
	      this variable is assigned a value, the  history  file  is	 trun‐
	      cated,  if  necessary,  to  contain  no more than that number of
	      lines by removing the oldest entries.  The history file is  also
	      truncated	 to this size after writing it when a shell exits.  If
	      the value is 0, the history file	is  truncated  to  zero	 size.
	      Non-numeric  values  and	numeric	 values less than zero inhibit
	      truncation.  The shell sets the default value to	the  value  of
	      HISTSIZE after reading any startup files.
       HISTIGNORE
	      A	 colon-separated list of patterns used to decide which command
	      lines should be saved on the history list.  Each pattern is  an‐
	      chored  at the beginning of the line and must match the complete
	      line (no implicit `*' is	appended).   Each  pattern  is	tested
	      against  the  line after the checks specified by HISTCONTROL are
	      applied.	In addition to the normal shell pattern matching char‐
	      acters,  `&'  matches the previous history line.	`&' may be es‐
	      caped using a backslash; the backslash  is  removed  before  at‐
	      tempting	a  match.  The second and subsequent lines of a multi-
	      line compound command are not tested, and are added to the  his‐
	      tory  regardless of the value of HISTIGNORE.  The pattern match‐
	      ing honors the setting of the extglob shell option.
       HISTSIZE
	      The number of commands to remember in the command	 history  (see
	      HISTORY  below).	 If  the value is 0, commands are not saved in
	      the history list.	 Numeric values less than zero result in every
	      command  being  saved  on	 the history list (there is no limit).
	      The shell sets the  default  value  to  500  after  reading  any
	      startup files.
       HISTTIMEFORMAT
	      If  this	variable  is  set and not null, its value is used as a
	      format string for strftime(3) to print the time stamp associated
	      with  each  history  entry displayed by the history builtin.  If
	      this variable is set, time stamps are  written  to  the  history
	      file  so they may be preserved across shell sessions.  This uses
	      the history comment character  to	 distinguish  timestamps  from
	      other history lines.
       HOME   The home directory of the current user; the default argument for
	      the cd builtin command.  The value of this variable is also used
	      when performing tilde expansion.
       HOSTFILE
	      Contains	the  name  of  a file in the same format as /etc/hosts
	      that should be read when the shell needs to complete a hostname.
	      The  list	 of possible hostname completions may be changed while
	      the shell is running; the next time hostname completion  is  at‐
	      tempted  after  the  value is changed, bash adds the contents of
	      the new file to the existing list.  If HOSTFILE is set, but  has
	      no  value,  or  does  not name a readable file, bash attempts to
	      read /etc/hosts to obtain the list of possible hostname  comple‐
	      tions.  When HOSTFILE is unset, the hostname list is cleared.
       IFS    The Internal Field Separator that is used for word splitting af‐
	      ter expansion and to  split  lines  into	words  with  the  read
	      builtin  command.	  The  default	value  is  ``<space><tab><new‐
	      line>''.
       IGNOREEOF
	      Controls the action of an interactive shell on receipt of an EOF
	      character as the sole input.  If set, the value is the number of
	      consecutive EOF characters which must  be	 typed	as  the	 first
	      characters  on an input line before bash exits.  If the variable
	      exists but does not have a numeric value, or has no  value,  the
	      default  value  is  10.  If it does not exist, EOF signifies the
	      end of input to the shell.
       INPUTRC
	      The filename for the readline startup file, overriding  the  de‐
	      fault of ~/.inputrc (see READLINE below).
       INSIDE_EMACS
	      If  this	variable  appears  in  the  environment when the shell
	      starts, bash assumes that it is running inside  an  Emacs	 shell
	      buffer  and  may disable line editing, depending on the value of
	      TERM.
       LANG   Used to determine the  locale  category  for  any	 category  not
	      specifically selected with a variable starting with LC_.
       LC_ALL This  variable  overrides	 the  value  of LANG and any other LC_
	      variable specifying a locale category.
       LC_COLLATE
	      This variable determines the collation order used	 when  sorting
	      the  results  of pathname expansion, and determines the behavior
	      of range expressions, equivalence	 classes,  and	collating  se‐
	      quences within pathname expansion and pattern matching.
       LC_CTYPE
	      This  variable  determines  the interpretation of characters and
	      the behavior of character classes within pathname expansion  and
	      pattern matching.
       LC_MESSAGES
	      This  variable  determines  the locale used to translate double-
	      quoted strings preceded by a $.
       LC_NUMERIC
	      This variable determines the locale  category  used  for	number
	      formatting.
       LC_TIME
	      This  variable  determines the locale category used for data and
	      time formatting.
       LINES  Used by the select compound  command  to	determine  the	column
	      length  for  printing selection lists.  Automatically set if the
	      checkwinsize option is enabled or in an interactive  shell  upon
	      receipt of a SIGWINCH.
       MAIL   If  this	parameter  is  set to a file or directory name and the
	      MAILPATH variable is not set, bash informs the user of  the  ar‐
	      rival of mail in the specified file or Maildir-format directory.
       MAILCHECK
	      Specifies	 how often (in seconds) bash checks for mail.  The de‐
	      fault is 60 seconds.  When it is time to	check  for  mail,  the
	      shell  does  so  before  displaying the primary prompt.  If this
	      variable is unset, or set to  a  value  that  is	not  a	number
	      greater than or equal to zero, the shell disables mail checking.
       MAILPATH
	      A colon-separated list of filenames to be checked for mail.  The
	      message to be printed when mail arrives in a particular file may
	      be  specified by separating the filename from the message with a
	      `?'.  When used in the text of the message, $_  expands  to  the
	      name of the current mailfile.  Example:
	      MAILPATH='/var/mail/bfox?"You  have  mail":~/shell-mail?"$_  has
	      mail!"'
	      Bash can be configured to supply a default value for this	 vari‐
	      able  (there  is	no  value by default), but the location of the
	      user  mail  files	 that  it  uses	 is  system  dependent	(e.g.,
	      /var/mail/$USER).
       OPTERR If set to the value 1, bash displays error messages generated by
	      the getopts builtin command (see SHELL BUILTIN COMMANDS  below).
	      OPTERR  is  initialized to 1 each time the shell is invoked or a
	      shell script is executed.
       PATH   The search path for commands.  It is a colon-separated  list  of
	      directories  in  which the shell looks for commands (see COMMAND
	      EXECUTION below).	 A zero-length (null) directory	 name  in  the
	      value of PATH indicates the current directory.  A null directory
	      name may appear as two adjacent colons,  or  as  an  initial  or
	      trailing	colon.	 The  default path is system-dependent, and is
	      set by the administrator who installs bash.  A common value is
	      ``/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:
	      /sbin''.
       POSIXLY_CORRECT
	      If this variable is in the environment  when  bash  starts,  the
	      shell  enters posix mode before reading the startup files, as if
	      the --posix invocation option had been supplied.	If it  is  set
	      while  the  shell is running, bash enables posix mode, as if the
	      command set -o posix had been executed.  When the	 shell	enters
	      posix mode, it sets this variable if it was not already set.
       PROMPT_COMMAND
	      If  this variable is set, and is an array, the value of each set
	      element is executed as a command prior to issuing	 each  primary
	      prompt.	If this is set but not an array variable, its value is
	      used as a command to execute instead.
       PROMPT_DIRTRIM
	      If set to a number greater than zero, the value is used  as  the
	      number of trailing directory components to retain when expanding
	      the \w and \W  prompt  string  escapes  (see  PROMPTING  below).
	      Characters removed are replaced with an ellipsis.
       PS0    The  value  of  this parameter is expanded (see PROMPTING below)
	      and displayed by interactive shells after reading a command  and
	      before the command is executed.
       PS1    The  value  of  this parameter is expanded (see PROMPTING below)
	      and used as the primary prompt string.   The  default  value  is
	      ``\s-\v\$ ''.
       PS2    The  value of this parameter is expanded as with PS1 and used as
	      the secondary prompt string.  The default is ``> ''.
       PS3    The value of this parameter is used as the prompt for the select
	      command (see SHELL GRAMMAR above).
       PS4    The  value  of  this  parameter  is expanded as with PS1 and the
	      value is printed before each command bash displays during an ex‐
	      ecution trace.  The first character of the expanded value of PS4
	      is replicated multiple times, as necessary, to indicate multiple
	      levels of indirection.  The default is ``+ ''.
       SHELL  This  variable expands to the full pathname to the shell.	 If it
	      is not set when the shell starts, bash assigns to	 it  the  full
	      pathname of the current user's login shell.
       TIMEFORMAT
	      The  value of this parameter is used as a format string specify‐
	      ing how the timing information for pipelines prefixed  with  the
	      time  reserved word should be displayed.	The % character intro‐
	      duces an escape sequence that is expanded to  a  time  value  or
	      other  information.  The escape sequences and their meanings are
	      as follows; the braces denote optional portions.
	      %%	A literal %.
	      %[p][l]R	The elapsed time in seconds.
	      %[p][l]U	The number of CPU seconds spent in user mode.
	      %[p][l]S	The number of CPU seconds spent in system mode.
	      %P	The CPU percentage, computed as (%U + %S) / %R.

	      The optional p is a digit specifying the precision,  the	number
	      of fractional digits after a decimal point.  A value of 0 causes
	      no decimal point or fraction to be output.  At most three places
	      after  the  decimal  point may be specified; values of p greater
	      than 3 are changed to 3.	If p is not specified, the value 3  is
	      used.

	      The  optional l specifies a longer format, including minutes, of
	      the form MMmSS.FFs.  The value of p determines  whether  or  not
	      the fraction is included.

	      If  this	variable  is not set, bash acts as if it had the value
	      $'\nreal\t%3lR\nuser\t%3lU\nsys\t%3lS'.  If the value  is	 null,
	      no timing information is displayed.  A trailing newline is added
	      when the format string is displayed.
       TMOUT  If set to a value greater than zero, TMOUT is treated as the de‐
	      fault  timeout  for the read builtin.  The select command termi‐
	      nates if input does not arrive after TMOUT seconds when input is
	      coming  from  a terminal.	 In an interactive shell, the value is
	      interpreted as the number of seconds to wait for a line of input
	      after issuing the primary prompt.	 Bash terminates after waiting
	      for that number of seconds if a complete line of input does  not
	      arrive.
       TMPDIR If  set, bash uses its value as the name of a directory in which
	      bash creates temporary files for the shell's use.
       auto_resume
	      This variable controls how the shell interacts with the user and
	      job  control.   If this variable is set, single word simple com‐
	      mands without redirections are treated as candidates for resump‐
	      tion of an existing stopped job.	There is no ambiguity allowed;
	      if there is more than one job beginning with the	string	typed,
	      the  job	most  recently	accessed  is  selected.	 The name of a
	      stopped job, in this context, is the command line used to	 start
	      it.   If	set to the value exact, the string supplied must match
	      the name of a stopped job exactly;  if  set  to  substring,  the
	      string  supplied	needs  to  match  a substring of the name of a
	      stopped job.  The substring value provides functionality	analo‐
	      gous  to the %?  job identifier (see JOB CONTROL below).	If set
	      to any other value, the supplied string must be a	 prefix	 of  a
	      stopped job's name; this provides functionality analogous to the
	      %string job identifier.
       histchars
	      The two or three characters which control history expansion  and
	      tokenization (see HISTORY EXPANSION below).  The first character
	      is the history expansion character, the character which  signals
	      the  start  of  a	 history  expansion, normally `!'.  The second
	      character is the quick substitution character, which is used  as
	      shorthand	 for  re-running the previous command entered, substi‐
	      tuting one string for another in the command.   The  default  is
	      `^'.   The optional third character is the character which indi‐
	      cates that the remainder of the line is a comment when found  as
	      the  first  character of a word, normally `#'.  The history com‐
	      ment character causes history substitution to be skipped for the
	      remaining	 words on the line.  It does not necessarily cause the
	      shell parser to treat the rest of the line as a comment.

   Arrays
       Bash provides one-dimensional indexed and associative array  variables.
       Any  variable may be used as an indexed array; the declare builtin will
       explicitly declare an array.  There is no maximum limit on the size  of
       an  array, nor any requirement that members be indexed or assigned con‐
       tiguously.  Indexed arrays are  referenced  using  integers  (including
       arithmetic expressions) and are zero-based; associative arrays are ref‐
       erenced using arbitrary strings.	 Unless otherwise noted, indexed array
       indices must be non-negative integers.

       An  indexed  array is created automatically if any variable is assigned
       to using the syntax name[subscript]=value.  The subscript is treated as
       an arithmetic expression that must evaluate to a number.	 To explicitly
       declare an indexed array, use declare -a name (see SHELL	 BUILTIN  COM‐
       MANDS  below).	declare	 -a name[subscript] is also accepted; the sub‐
       script is ignored.

       Associative arrays are created using declare -A name.

       Attributes may be specified for an array variable using the declare and
       readonly builtins.  Each attribute applies to all members of an array.

       Arrays	are  assigned  to  using  compound  assignments	 of  the  form
       name=(value1 ... valuen), where each value may be  of  the  form	 [sub‐
       script]=string.	 Indexed array assignments do not require anything but
       string.	Each value in the list is expanded using all the shell	expan‐
       sions  described	 below under EXPANSION.	 When assigning to indexed ar‐
       rays, if the optional brackets and subscript are supplied,  that	 index
       is assigned to; otherwise the index of the element assigned is the last
       index assigned to by the statement plus one.  Indexing starts at zero.

       When assigning to an associative array, the words in a compound assign‐
       ment  may  be  either assignment statements, for which the subscript is
       required, or a list of words that is interpreted as a sequence  of  al‐
       ternating  keys and values: name=( key1 value1 key2 value2 ...).	 These
       are treated identically to  name=(  [key1]=value1  [key2]=value2	 ...).
       The  first  word in the list determines how the remaining words are in‐
       terpreted; all assignments in a list must be of the  same  type.	  When
       using  key/value	 pairs,	 the keys may not be missing or empty; a final
       missing value is treated like the empty string.

       This syntax is also accepted by the declare builtin.  Individual	 array
       elements	 may be assigned to using the name[subscript]=value syntax in‐
       troduced above.	When assigning to an indexed array, if	name  is  sub‐
       scripted	 by  a negative number, that number is interpreted as relative
       to one greater than the maximum index  of  name,	 so  negative  indices
       count back from the end of the array, and an index of -1 references the
       last element.

       Any element of an array may  be	referenced  using  ${name[subscript]}.
       The braces are required to avoid conflicts with pathname expansion.  If
       subscript is @ or *, the word expands to all members  of	 name.	 These
       subscripts  differ only when the word appears within double quotes.  If
       the word is double-quoted, ${name[*]} expands to a single word with the
       value  of each array member separated by the first character of the IFS
       special variable, and ${name[@]} expands each element of name to a sep‐
       arate  word.   When  there  are no array members, ${name[@]} expands to
       nothing.	 If the double-quoted expansion occurs within a word, the  ex‐
       pansion of the first parameter is joined with the beginning part of the
       original word, and the expansion of the last parameter is  joined  with
       the last part of the original word.  This is analogous to the expansion
       of the special parameters *  and	 @  (see  Special  Parameters  above).
       ${#name[subscript]}  expands  to	 the length of ${name[subscript]}.  If
       subscript is * or @, the expansion is the number of elements in the ar‐
       ray.  If the subscript used to reference an element of an indexed array
       evaluates to a number less than zero, it is interpreted as relative  to
       one  greater  than  the maximum index of the array, so negative indices
       count back from the end of the array, and an index of -1 references the
       last element.

       Referencing an array variable without a subscript is equivalent to ref‐
       erencing the array with a subscript of 0.  Any reference to a  variable
       using a valid subscript is legal, and bash will create an array if nec‐
       essary.

       An array variable is considered set if a subscript has been assigned  a
       value.  The null string is a valid value.

       It  is possible to obtain the keys (indices) of an array as well as the
       values.	${!name[@]} and ${!name[*]} expand to the indices assigned  in
       array variable name.  The treatment when in double quotes is similar to
       the expansion of the special parameters @ and * within double quotes.

       The unset builtin is used to destroy arrays.  unset name[subscript] de‐
       stroys the array element at index subscript, for both indexed and asso‐
       ciative arrays.	Negative subscripts to indexed arrays are  interpreted
       as  described  above.   Unsetting the last element of an array variable
       does not unset the variable.  unset name, where name is	an  array,  or
       unset  name[subscript],	where  subscript is * or @, removes the entire
       array.

       When using a variable name with a subscript as an argument  to  a  com‐
       mand,  such  as with unset, without using the word expansion syntax de‐
       scribed above, the argument is subject to pathname expansion.  If path‐
       name expansion is not desired, the argument should be quoted.

       The  declare,  local,  and readonly builtins each accept a -a option to
       specify an indexed array and a -A option to specify an associative  ar‐
       ray.   If  both	options	 are  supplied, -A takes precedence.  The read
       builtin accepts a -a option to assign a list of	words  read  from  the
       standard input to an array.  The set and declare builtins display array
       values in a way that allows them to be reused as assignments.

EXPANSION
       Expansion is performed on the command line after it has been split into
       words.	There are seven kinds of expansion performed: brace expansion,
       tilde expansion, parameter and variable	expansion,  command  substitu‐
       tion, arithmetic expansion, word splitting, and pathname expansion.

       The order of expansions is: brace expansion; tilde expansion, parameter
       and variable expansion, arithmetic expansion, and command  substitution
       (done  in a left-to-right fashion); word splitting; and pathname expan‐
       sion.

       On systems that can support it, there is an additional expansion avail‐
       able:  process  substitution.   This  is	 performed at the same time as
       tilde, parameter, variable, and arithmetic expansion and	 command  sub‐
       stitution.

       After  these  expansions are performed, quote characters present in the
       original word are removed  unless  they	have  been  quoted  themselves
       (quote removal).

       Only  brace  expansion,	word splitting, and pathname expansion can in‐
       crease the number of words of the expansion; other expansions expand  a
       single  word to a single word.  The only exceptions to this are the ex‐
       pansions	 of  "$@"  and	"${name[@]}",  and,  in	 most  cases,  $*  and
       ${name[*]} as explained above (see PARAMETERS).

   Brace Expansion
       Brace expansion is a mechanism by which arbitrary strings may be gener‐
       ated.  This mechanism is similar to pathname expansion, but  the	 file‐
       names generated need not exist.	Patterns to be brace expanded take the
       form of an optional preamble, followed by either a series of comma-sep‐
       arated  strings or a sequence expression between a pair of braces, fol‐
       lowed by an optional postscript.	 The  preamble	is  prefixed  to  each
       string contained within the braces, and the postscript is then appended
       to each resulting string, expanding left to right.

       Brace expansions may be nested.	The results of	each  expanded	string
       are  not	 sorted;  left	to  right  order  is  preserved.  For example,
       a{d,c,b}e expands into `ade ace abe'.

       A sequence expression takes the form {x..y[..incr]}, where x and y  are
       either  integers or single characters, and incr, an optional increment,
       is an integer.  When integers are supplied, the expression  expands  to
       each  number between x and y, inclusive.	 Supplied integers may be pre‐
       fixed with 0 to force each term to have the same width.	When either  x
       or  y  begins  with  a  zero, the shell attempts to force all generated
       terms to contain the same number of digits, zero-padding	 where	neces‐
       sary.   When  characters	 are  supplied, the expression expands to each
       character lexicographically between x and y, inclusive, using  the  de‐
       fault C locale.	Note that both x and y must be of the same type.  When
       the increment is supplied, it is used as the  difference	 between  each
       term.  The default increment is 1 or -1 as appropriate.

       Brace expansion is performed before any other expansions, and any char‐
       acters special to other expansions are preserved in the result.	It  is
       strictly	 textual.  Bash does not apply any syntactic interpretation to
       the context of the expansion or the text between the braces.

       A correctly-formed brace expansion must contain	unquoted  opening  and
       closing braces, and at least one unquoted comma or a valid sequence ex‐
       pression.  Any incorrectly formed brace expansion is left unchanged.  A
       {  or  , may be quoted with a backslash to prevent its being considered
       part of a brace expression.  To avoid conflicts with  parameter	expan‐
       sion, the string ${ is not considered eligible for brace expansion, and
       inhibits brace expansion until the closing }.

       This construct is typically used as shorthand when the common prefix of
       the strings to be generated is longer than in the above example:

	      mkdir /usr/local/src/bash/{old,new,dist,bugs}
       or
	      chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}

       Brace  expansion	 introduces  a	slight incompatibility with historical
       versions of sh.	sh does not treat opening or closing braces  specially
       when  they  appear as part of a word, and preserves them in the output.
       Bash removes braces from words as a  consequence	 of  brace  expansion.
       For  example,  a word entered to sh as file{1,2} appears identically in
       the output.  The same word is output as file1 file2 after expansion  by
       bash.   If strict compatibility with sh is desired, start bash with the
       +B option or disable brace expansion with the +B option to the set com‐
       mand (see SHELL BUILTIN COMMANDS below).

   Tilde Expansion
       If  a  word  begins  with an unquoted tilde character (`~'), all of the
       characters preceding the first unquoted slash (or  all  characters,  if
       there  is no unquoted slash) are considered a tilde-prefix.  If none of
       the characters in the tilde-prefix are quoted, the  characters  in  the
       tilde-prefix  following the tilde are treated as a possible login name.
       If this login name is the null string, the tilde is replaced  with  the
       value  of  the shell parameter HOME.  If HOME is unset, the home direc‐
       tory of the user executing the shell is	substituted  instead.	Other‐
       wise,  the  tilde-prefix is replaced with the home directory associated
       with the specified login name.

       If the tilde-prefix is a `~+', the value of the shell variable PWD  re‐
       places  the  tilde-prefix.  If the tilde-prefix is a `~-', the value of
       the shell variable OLDPWD, if it is set, is substituted.	 If the	 char‐
       acters  following  the tilde in the tilde-prefix consist of a number N,
       optionally prefixed by a `+' or a `-',  the  tilde-prefix  is  replaced
       with the corresponding element from the directory stack, as it would be
       displayed by the dirs builtin invoked with the tilde-prefix as an argu‐
       ment.   If  the characters following the tilde in the tilde-prefix con‐
       sist of a number without a leading `+' or `-', `+' is assumed.

       If the login name is invalid, or the tilde expansion fails, the word is
       unchanged.

       Each variable assignment is checked for unquoted tilde-prefixes immedi‐
       ately following a : or the first =.  In these cases, tilde expansion is
       also performed.	Consequently, one may use filenames with tildes in as‐
       signments to PATH, MAILPATH, and CDPATH, and the shell assigns the  ex‐
       panded value.

       Bash  also  performs tilde expansion on words satisfying the conditions
       of variable assignments (as described above under PARAMETERS) when they
       appear  as arguments to simple commands.	 Bash does not do this, except
       for the declaration commands listed above, when in posix mode.

   Parameter Expansion
       The `$' character introduces parameter expansion, command substitution,
       or  arithmetic  expansion.  The parameter name or symbol to be expanded
       may be enclosed in braces, which are optional but serve to protect  the
       variable	 to be expanded from characters immediately following it which
       could be interpreted as part of the name.

       When braces are used, the matching ending brace is the  first  `}'  not
       escaped by a backslash or within a quoted string, and not within an em‐
       bedded arithmetic expansion, command substitution, or parameter	expan‐
       sion.

       ${parameter}
	      The  value of parameter is substituted.  The braces are required
	      when parameter is a positional  parameter	 with  more  than  one
	      digit, or when parameter is followed by a character which is not
	      to be interpreted as part of its name.  The parameter is a shell
	      parameter	 as  described above PARAMETERS) or an array reference
	      (Arrays).

       If the first character of parameter is an exclamation  point  (!),  and
       parameter is not a nameref, it introduces a level of indirection.  Bash
       uses the value formed by expanding the rest of parameter as the new pa‐
       rameter;	 this  is  then expanded and that value is used in the rest of
       the expansion, rather than the expansion	 of  the  original  parameter.
       This is known as indirect expansion.  The value is subject to tilde ex‐
       pansion, parameter expansion, command substitution, and arithmetic  ex‐
       pansion.	  If  parameter	 is a nameref, this expands to the name of the
       parameter referenced by parameter instead of  performing	 the  complete
       indirect	 expansion.   The  exceptions  to  this	 are the expansions of
       ${!prefix*} and ${!name[@]} described  below.   The  exclamation	 point
       must  immediately  follow the left brace in order to introduce indirec‐
       tion.

       In each of the cases below, word is subject to tilde expansion, parame‐
       ter expansion, command substitution, and arithmetic expansion.

       When not performing substring expansion, using the forms documented be‐
       low (e.g., :-), bash tests for a	 parameter  that  is  unset  or	 null.
       Omitting	 the  colon results in a test only for a parameter that is un‐
       set.

       ${parameter:-word}
	      Use Default Values.  If parameter is unset or null,  the	expan‐
	      sion  of word is substituted.  Otherwise, the value of parameter
	      is substituted.
       ${parameter:=word}
	      Assign Default Values.  If parameter is unset or null,  the  ex‐
	      pansion  of word is assigned to parameter.  The value of parame‐
	      ter is then substituted.	Positional parameters and special  pa‐
	      rameters may not be assigned to in this way.
       ${parameter:?word}
	      Display  Error if Null or Unset.	If parameter is null or unset,
	      the expansion of word (or a message to that effect  if  word  is
	      not  present) is written to the standard error and the shell, if
	      it is not interactive, exits.  Otherwise, the value of parameter
	      is substituted.
       ${parameter:+word}
	      Use  Alternate Value.  If parameter is null or unset, nothing is
	      substituted, otherwise the expansion of word is substituted.
       ${parameter:offset}
       ${parameter:offset:length}
	      Substring Expansion.  Expands to up to length characters of  the
	      value  of	 parameter starting at the character specified by off‐
	      set.  If parameter is @, an indexed array subscripted by @ or *,
	      or  an  associative  array name, the results differ as described
	      below.  If length is omitted, expands to the  substring  of  the
	      value of parameter starting at the character specified by offset
	      and extending to the end of the value.  length  and  offset  are
	      arithmetic expressions (see ARITHMETIC EVALUATION below).

	      If  offset  evaluates  to	 a number less than zero, the value is
	      used as an offset in characters from the end of the value of pa‐
	      rameter.	 If length evaluates to a number less than zero, it is
	      interpreted as an offset in characters from the end of the value
	      of  parameter rather than a number of characters, and the expan‐
	      sion is the characters between offset  and  that	result.	  Note
	      that  a  negative	 offset must be separated from the colon by at
	      least one space to avoid being confused with the :- expansion.

	      If parameter is @, the result is	length	positional  parameters
	      beginning at offset.  A negative offset is taken relative to one
	      greater than the greatest positional parameter, so an offset  of
	      -1  evaluates to the last positional parameter.  It is an expan‐
	      sion error if length evaluates to a number less than zero.

	      If parameter is an indexed array name subscripted by @ or *, the
	      result  is  the length members of the array beginning with ${pa‐
	      rameter[offset]}.	 A negative offset is taken  relative  to  one
	      greater than the maximum index of the specified array.  It is an
	      expansion error if length evaluates to a number less than zero.

	      Substring expansion applied to an associative array produces un‐
	      defined results.

	      Substring	 indexing  is zero-based unless the positional parame‐
	      ters are used, in which case the indexing starts	at  1  by  de‐
	      fault.   If offset is 0, and the positional parameters are used,
	      $0 is prefixed to the list.

       ${!prefix*}
       ${!prefix@}
	      Names matching prefix.  Expands to the names of variables	 whose
	      names begin with prefix, separated by the first character of the
	      IFS special variable.  When @ is used and the expansion  appears
	      within  double  quotes, each variable name expands to a separate
	      word.

       ${!name[@]}
       ${!name[*]}
	      List of array keys.  If name is an array	variable,  expands  to
	      the  list	 of array indices (keys) assigned in name.  If name is
	      not an array, expands to 0 if name is set	 and  null  otherwise.
	      When  @  is used and the expansion appears within double quotes,
	      each key expands to a separate word.

       ${#parameter}
	      Parameter length.	 The length in characters of the value of  pa‐
	      rameter  is substituted.	If parameter is * or @, the value sub‐
	      stituted is the number of positional parameters.	 If  parameter
	      is an array name subscripted by * or @, the value substituted is
	      the number of elements in the array.  If parameter is an indexed
	      array  name subscripted by a negative number, that number is in‐
	      terpreted as relative to one greater than the maximum  index  of
	      parameter,  so  negative	indices count back from the end of the
	      array, and an index of -1 references the last element.

       ${parameter#word}
       ${parameter##word}
	      Remove matching prefix pattern.  The word is expanded to produce
	      a pattern just as in pathname expansion, and matched against the
	      expanded value of parameter using the rules described under Pat‐
	      tern  Matching  below.   If the pattern matches the beginning of
	      the value of parameter, then the result of the expansion is  the
	      expanded	value  of parameter with the shortest matching pattern
	      (the ``#'' case) or the longest  matching	 pattern  (the	``##''
	      case)  deleted.  If parameter is @ or *, the pattern removal op‐
	      eration is applied to each positional parameter in turn, and the
	      expansion is the resultant list.	If parameter is an array vari‐
	      able subscripted with @ or *, the pattern removal	 operation  is
	      applied  to  each member of the array in turn, and the expansion
	      is the resultant list.

       ${parameter%word}
       ${parameter%%word}
	      Remove matching suffix pattern.  The word is expanded to produce
	      a pattern just as in pathname expansion, and matched against the
	      expanded value of parameter using the rules described under Pat‐
	      tern  Matching below.  If the pattern matches a trailing portion
	      of the expanded value of parameter, then the result of  the  ex‐
	      pansion  is  the	expanded  value of parameter with the shortest
	      matching pattern (the ``%'' case) or the longest	matching  pat‐
	      tern  (the  ``%%''  case)	 deleted.  If parameter is @ or *, the
	      pattern removal operation is applied to each positional  parame‐
	      ter in turn, and the expansion is the resultant list.  If param‐
	      eter is an array variable subscripted with @ or *,  the  pattern
	      removal  operation  is  applied  to  each member of the array in
	      turn, and the expansion is the resultant list.

       ${parameter/pattern/string}
	      Pattern substitution.  The pattern is expanded to produce a pat‐
	      tern  just  as  in pathname expansion, Parameter is expanded and
	      the longest match of pattern against its value is replaced  with
	      string.	The match is performed using the rules described under
	      Pattern Matching below.  If pattern begins with /,  all  matches
	      of  pattern  are	replaced with string.  Normally only the first
	      match is replaced.  If pattern begins with #, it must  match  at
	      the  beginning  of  the expanded value of parameter.  If pattern
	      begins with %, it must match at the end of the expanded value of
	      parameter.   If  string  is null, matches of pattern are deleted
	      and the / following pattern may be omitted.  If the  nocasematch
	      shell  option  is enabled, the match is performed without regard
	      to the case of alphabetic characters.  If parameter is @	or  *,
	      the substitution operation is applied to each positional parame‐
	      ter in turn, and the expansion is the resultant list.  If param‐
	      eter is an array variable subscripted with @ or *, the substitu‐
	      tion operation is applied to each member of the array  in	 turn,
	      and the expansion is the resultant list.

       ${parameter^pattern}
       ${parameter^^pattern}
       ${parameter,pattern}
       ${parameter,,pattern}
	      Case  modification.   This expansion modifies the case of alpha‐
	      betic characters in parameter.  The pattern is expanded to  pro‐
	      duce a pattern just as in pathname expansion.  Each character in
	      the expanded value of parameter is tested against pattern,  and,
	      if  it  matches the pattern, its case is converted.  The pattern
	      should not attempt to match more than one character.  The ^  op‐
	      erator converts lowercase letters matching pattern to uppercase;
	      the , operator converts matching uppercase letters to lowercase.
	      The  ^^  and ,, expansions convert each matched character in the
	      expanded value; the ^ and , expansions match  and	 convert  only
	      the  first character in the expanded value.  If pattern is omit‐
	      ted, it is treated like a ?, which matches every character.   If
	      parameter	 is @ or *, the case modification operation is applied
	      to each positional parameter in turn, and the expansion  is  the
	      resultant	 list.	 If parameter is an array variable subscripted
	      with @ or *, the case modification operation is applied to  each
	      member  of the array in turn, and the expansion is the resultant
	      list.

       ${parameter@operator}
	      Parameter transformation.	 The expansion is either a transforma‐
	      tion  of	the  value of parameter or information about parameter
	      itself, depending on the value of operator.  Each operator is  a
	      single letter:

	      U	     The  expansion is a string that is the value of parameter
		     with lowercase alphabetic characters converted to	upper‐
		     case.
	      u	     The  expansion is a string that is the value of parameter
		     with the first character converted to uppercase, if it is
		     alphabetic.
	      L	     The  expansion is a string that is the value of parameter
		     with uppercase alphabetic characters converted to	lower‐
		     case.
	      Q	     The  expansion is a string that is the value of parameter
		     quoted in a format that can be reused as input.
	      E	     The expansion is a string that is the value of  parameter
		     with  backslash  escape  sequences	 expanded  as with the
		     $'...' quoting mechanism.
	      P	     The expansion is a string that is the result of expanding
		     the value of parameter as if it were a prompt string (see
		     PROMPTING below).
	      A	     The expansion is a string in the form  of	an  assignment
		     statement	or  declare  command  that, if evaluated, will
		     recreate parameter with its attributes and value.
	      K	     Produces a possibly-quoted version of the value of param‐
		     eter, except that it prints the values of indexed and as‐
		     sociative arrays as a sequence of quoted key-value	 pairs
		     (see Arrays above).
	      a	     The  expansion is a string consisting of flag values rep‐
		     resenting parameter's attributes.

	      If parameter is @ or *, the operation is applied to  each	 posi‐
	      tional  parameter	 in  turn,  and the expansion is the resultant
	      list.  If parameter is an array variable subscripted with	 @  or
	      *, the operation is applied to each member of the array in turn,
	      and the expansion is the resultant list.

	      The result of the expansion is subject  to  word	splitting  and
	      pathname expansion as described below.

   Command Substitution
       Command substitution allows the output of a command to replace the com‐
       mand name.  There are two forms:

	      $(command)
       or
	      `command`

       Bash performs the expansion by executing command in a subshell environ‐
       ment and replacing the command substitution with the standard output of
       the command, with any trailing newlines deleted.	 Embedded newlines are
       not  deleted,  but they may be removed during word splitting.  The com‐
       mand substitution $(cat file) can be replaced  by  the  equivalent  but
       faster $(< file).

       When  the  old-style  backquote form of substitution is used, backslash
       retains its literal meaning except when followed by $, `,  or  \.   The
       first backquote not preceded by a backslash terminates the command sub‐
       stitution.  When using the $(command) form, all characters between  the
       parentheses make up the command; none are treated specially.

       Command substitutions may be nested.  To nest when using the backquoted
       form, escape the inner backquotes with backslashes.

       If the substitution appears within double quotes,  word	splitting  and
       pathname expansion are not performed on the results.

   Arithmetic Expansion
       Arithmetic  expansion allows the evaluation of an arithmetic expression
       and the substitution of the result.  The format for  arithmetic	expan‐
       sion is:

	      $((expression))

       The  old	 format $[expression] is deprecated and will be removed in up‐
       coming versions of bash.

       The expression is treated as if it were within  double  quotes,	but  a
       double  quote inside the parentheses is not treated specially.  All to‐
       kens in the expression undergo parameter and variable  expansion,  com‐
       mand  substitution,  and	 quote	removal.  The result is treated as the
       arithmetic expression to be evaluated.  Arithmetic  expansions  may  be
       nested.

       The  evaluation	is performed according to the rules listed below under
       ARITHMETIC EVALUATION.  If expression is invalid, bash prints a message
       indicating failure and no substitution occurs.

   Process Substitution
       Process	substitution allows a process's input or output to be referred
       to using a filename.  It takes the form of  <(list)  or	>(list).   The
       process	list is run asynchronously, and its input or output appears as
       a filename.  This filename is passed as an argument to the current com‐
       mand  as	 the  result  of  the expansion.  If the >(list) form is used,
       writing to the file will provide input for list.	 If the	 <(list)  form
       is  used,  the  file passed as an argument should be read to obtain the
       output of list.	Process substitution is supported on systems that sup‐
       port named pipes (FIFOs) or the /dev/fd method of naming open files.

       When  available,	 process substitution is performed simultaneously with
       parameter and variable expansion, command substitution, and  arithmetic
       expansion.

   Word Splitting
       The  shell  scans the results of parameter expansion, command substitu‐
       tion, and arithmetic expansion that did not occur within double	quotes
       for word splitting.

       The  shell  treats each character of IFS as a delimiter, and splits the
       results of the other expansions into words using	 these	characters  as
       field   terminators.   If  IFS  is  unset,  or  its  value  is  exactly
       <space><tab><newline>, the default, then sequences of  <space>,	<tab>,
       and  <newline>  at the beginning and end of the results of the previous
       expansions are ignored, and any sequence of IFS characters not  at  the
       beginning  or  end  serves  to delimit words.  If IFS has a value other
       than the default, then sequences of the	whitespace  characters	space,
       tab,  and  newline are ignored at the beginning and end of the word, as
       long as the whitespace character is in the value of IFS (an IFS	white‐
       space  character).   Any	 character  in IFS that is not IFS whitespace,
       along with any adjacent IFS whitespace characters, delimits a field.  A
       sequence	 of  IFS whitespace characters is also treated as a delimiter.
       If the value of IFS is null, no word splitting occurs.

       Explicit null arguments ("" or '') are retained and passed to  commands
       as empty strings.  Unquoted implicit null arguments, resulting from the
       expansion of parameters that have no values, are removed.  If a parame‐
       ter with no value is expanded within double quotes, a null argument re‐
       sults and is retained and passed to a command as an empty string.  When
       a  quoted  null	argument  appears as part of a word whose expansion is
       non-null, the null argument is removed.	That is, the word -d'' becomes
       -d after word splitting and null argument removal.

       Note that if no expansion occurs, no splitting is performed.

   Pathname Expansion
       After  word  splitting,	unless	the -f option has been set, bash scans
       each word for the characters *, ?, and [.  If one of  these  characters
       appears, and is not quoted, then the word is regarded as a pattern, and
       replaced with an alphabetically sorted list of filenames	 matching  the
       pattern	(see  Pattern  Matching	 below).  If no matching filenames are
       found, and the shell option nullglob is not enabled, the word  is  left
       unchanged.   If	the  nullglob option is set, and no matches are found,
       the word is removed.  If the failglob  shell  option  is	 set,  and  no
       matches	are  found, an error message is printed and the command is not
       executed.  If the shell option nocaseglob is enabled, the match is per‐
       formed  without regard to the case of alphabetic characters.  Note that
       when using range expressions like [a-z] (see  below),  letters  of  the
       other  case  may	 be  included, depending on the setting of LC_COLLATE.
       When a pattern is used for pathname expansion, the character ``.''   at
       the  start  of  a name or immediately following a slash must be matched
       explicitly, unless the shell option  dotglob  is	 set.	The  filenames
       ``.''   and  ``..''  must always be matched explicitly, even if dotglob
       is set.	In other cases, the ``.''  character is not treated specially.
       When  matching  a  pathname, the slash character must always be matched
       explicitly by a slash in the pattern, but in other matching contexts it
